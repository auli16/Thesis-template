\chapter{Studio e ricerca preliminare}
\label{cap:analisi-preliminare}

\intro{In questo capitolo vengono descritte nel dettaglio tutte le problematiche da risolvere durante lo sviluppo del progetto.
Verranno illustrate nel dettaglio le varie metodologie individuate per poter rendere di maggiore qualità le risposte fornite dal RALM tramite il raggiungimento dei diversi obiettivi.} \\

\section{Analisi dei requisiti}

\subsubsection{Requisiti}
\label{subsec:requisiti}
Una prima versione di backend dei servizi di estrazione di testo era già disponibile e lo scopo di questo progetto era quello di migliorare proprio quest'ultimo raggiungendo i seguenti obbiettivi:

\begin{itemize}
    \item Obbligatori:
    \subitem \gls{Parsing}\glsfirstoccur ad-hoc per documenti in cui le componenti grafiche contribuiscono alla semantica (es. tabelle e immagini);
    \subitem Estrapolazione, per alcuni formati dove sia possibile, della struttura logica del documento (es. individuando titoli e paragrafi);
    \subitem Pulizia del testo estratto dai documenti (es. eliminazione delle componenti inutili come gli indici e i sommari).
    \item Desiderabili:
    \subitem Interpretazione delle immagini allo scopo di arricchire i \gls{chunk}\glsfirstoccur in cui sono contestualizzate. 
\end{itemize}

I formati dei file considerati in questo stage sono stati i seguenti:
\begin{itemize}
    \item Pdf;
    \item Docx;
    \item HTML.
\end{itemize}

\subsection{Problematiche}
Non sempre il RALM è in grado di fornire una risposta corretta o soddisfacente.
Diverse sono state le criticità da risolvere durante lo sviluppo sia per quanto riguarda il rendere più comprensibile il contenuto al RALM, sia per quanto riguarda le conversioni dei documenti nei vari formati.
Tika, il tool utilizzato per estrarre il contenuto in testo non strutturato, durante la conversione ha delle perdite sulla struttura del contenuto come ad esempio le perdite di informazioni sulla struttura delle tabelle oppure sulla struttura del documento in sè (titolo, paragrafi, sottoparagrafi).
Per agevolare la comprensione del RALM, velocizzare le operazioni di ricerca dell'informazione e fare in modo di aumentare la probabilità che le risposte siano corrette è necessario trovare un modo per mantenere in maniera efficace queste strutture all'interno del testo semplice.
Un vantaggio di Tika è che può anche convertire il contenuto in formati strutturati come l'XHTML.
Grazie a questa funzione sarebbe già possibile individuare titoli, paragrafi e tabelle del documento ma, purtroppo, non è possibile farlo in tutti i formati: per i file HTML e Docx, dove c'è già una struttura di base, Tika riesce a identificare i vari elementi semantici, mentre con i Pdf la questione risulta più complessa.
Inoltre, non sempre, Tika riesce a ottenere la struttura esatta della tabella rispetto a come è rappresentata.
L'ultimo punto da analizzare è la questione delle ripetizioni di alcuni caratteri come segni di punteggiatura, newline e spazi: chiaramente Tika non è in grado di riconoscere quando ci sono degli elementi superflui all'interno del contenuto, è necessario quindi capire come fare per ridurre al minimo la quantità di caratteri all'interno del testo. 


\section{Ricerca e studio preliminare}
\subsection{Table Question Answering}
Nel \gls{TQA} le domande poste dall'utente cercano di avere una risposta precisa con i dati ricavati da delle tabelle.
L'obiettivo è quello di migliorare l'accesso e la comprensione delle informazioni strutturate contenute nelle tabelle.

\subsubsection{Linearizzazione delle tabelle}
\label{subsubsec-lin-tab}
Una tabella può assumere moltissime strutture e per questo è stato deciso di considerare solamente le tabelle che avessero come prima riga 
un'intesazione orizzontale e nelle righe successive i vari dati (esempio: tabella \ref{tab:esempio-cibo}).

\begin{table}[H]
    \centering
    \begin{tabular}{|p{3cm} |p{2cm} |p{2cm}| p{2cm}| p{2cm}|}
        \hline
        Cibo & Quantità & Energia(KCal) & Carboidrati(g) & Proteine(g) \\
        \hline
        Pennette rigate & 100g & 359 & 71 & 13 \\
        \hline
        Latte & 100ml & 47 & 4,9 & 3,2 \\
        \hline
        Banana & 100g & 89 & 23 & 1,1 \\
        \hline
    \end{tabular}
    \caption{Esempio di tabella presa in considerazione (valori approssimativi).}
    \label{tab:esempio-cibo}
\end{table}
\noindent Come specificato precedentemente le tabelle al momento dell'estrazione venivano linearizzate in testo semplice
perdendo alcune informazioni necessarie per la lettura effettuata dal RALM. 

\noindent Per esempio la tabella \ref{tab:esempio-cibo} verrebbe linearizzata in questa maniera:
\begin{tcolorbox}[colback=white, colframe=black]
    Cibo Quantità Energia(KCal) Carboidrati(g) Proteine(g) Pennette rigate  100g  359  71  13 Latte 100ml 47 4,9 3,2 Banana  100g 89 23 1,1
\end{tcolorbox}
\noindent La tabella linearizzata perde quindi le informazioni sulla struttura e come risultato abbiamo una serie di valori posti senza avere troppo senso in fase di lettura per un RALM. \\

\subsubsection{L'idea}
\noindent Dopo un attenta ricerca effettuata su vari documenti scientifici sono riuscito ad individuare un modo semplice ed efficace per mantenere 
l'informazione nella tabella linearizzata e la sua struttura:
\begin{itemize}
    \item All'inizio di ogni riga viene scritto "Riga n->" dove n sta per il numero della riga;
    \item Per ogni cella presente nella tabella vengono concatenati il valore dell'intestazione della colonna dov'è presente il valore e il valore della cella separati dal carattere ":";
    \item Ogni cella viene poi separata dall'altra con il carattere "|".
    \item A chiudere la riga viene inserito il carattere di escape per newline.
\end{itemize} 

Quindi la tabella \ref{tab:esempio-cibo} viene linearizzata in questo modo:
\begin{tcolorbox}[colback=white, colframe=black]
    Riga0->Cibo: Pennette rigate|Quantità:100g|Energia(KCal):359|Carboidrati(g): \\
    71|Proteine(g):13| \\
    Riga1->Cibo: Latte|Quantità:100ml|Energia(KCal):47|Carboidrati(g):4,9|\\
    Proteine(g):3,2| \\
    Riga2->Cibo: Banana|Quantità:100g|Energia(KCal):89|Carboidrati(g):23|\\
    Proteine(g):1,1|
\end{tcolorbox}

Nel metodo scritto sul seguente articolo scientifico "\cite{art:multimodelqa} (paragrafo 4 \emph{Models}, sottosezione \emph{Table QA Module})" utilizza come sepratori di cella il carattare ';' e come speratore dal numero di riga alla prima cella il carattere ':'.
I caratteri ':' e ';' potrebbero comparire con molta più frequenza all'interno dei valori delle celle e in questo modo si avrebbe un doppio significato per questi ultimi, cioè sarebbero sia un separatore che una parte di dato, il RALM quindi potrebbe avere dei problemi nel riconoscere questa differenza. 



\subsection{Chunking}
\paragraph{Procedimento}
Il \emph{chunking} è il procedimento mediante il quale in contenuto testuale di un documento viene suddiviso in parti più piccole chiamate chunk.
\noindent Per poter fornire una risposta ben strutturata viene utilizzato un \emph{\gls{Chat-Completion Model}}\glsfirstoccur che riceve in ingresso una richiesta e tramite quest'ultima è in grado di costruire una risposta ben strutturata.
La richiesta è formata dalla domanda dell'utente seguita dai chunk a cui il motore di ricerca ha dato lo score più alto.
Il modello in ingresso può prendere un numero limitato di \emph{token} quindi non gli si può dare l'intero contenuto del documento, ha bisogno di questa suddivisione.

\noindent Per poter capire al meglio il significato delle parole presenti in un determinato contesto è necessario dover spezzare i chunk in \emph{token}.
Il \emph{token} indica una singola unità linguistica o comunque un elemento individuale all'interno di un testo e può rappresentare per esempio una parola, un simbolo di punteggiatura o anche una parte di una parola.
Qui di seguito viene spiegato come il motore di ricerca è in grado di assegnare lo score ai vari chunk e quindi come si riesce a capire quali sono i chunk che come contenuto avranno con maggior probabilità la risposta che si sta cercando.

\subsubsection{Recupero delle informazioni}
\label{subsubsec:rec-inf}
\paragraph{\gls{BM25}}
BM25 è una ranking function usata dai motori di ricerca, è un algoritmo di tipo \emph{\gls{Bag-of-Words}}\glsfirstoccur e calcola un punteggio per ogni chunk
presente in base alla frequenza di vari termini presenti nella query di ricerca (informazioni ricavate da \cite{site:wikiOkapi}). 

\paragraph{Vector search}
Tramite la vector search vengono generate rappresentazioni vettoriali dei dati ed è possibile calcolare la similarità tra i vettori.
Per poter riconoscere il vero significato attribuito ad una parola i chunk vengono suddivisi a loro volta in token.
Grazie a questi token è possibile calcolare la distanza tra i vettori tramite.
Il tipo di distanza utilizzata in questo progetto è stata la \emph{Cosine Distance}.

\subparagraph{Cosine similarity}
La \emph{Cosine similarity} misura l'angolo tra due vettori in uno spazio multidimensionale (con l'idea che due vettori simili puntino in direzioni simili).
La cosine similarity e la cosine distance hanno una relazione inversa: all'aumentare della distanza la similarità diminuisce e viceversa.

\noindent Dati due vettori A,B la \emph{cosine similarity} viene calcolata come segue:

\[
\text{Cos(A,B)} = \frac{{\mathbf{A} \cdot \mathbf{B}}}{{\|\mathbf{A}\| \cdot \|\mathbf{B}\|}}    
\]

\[
\text{Cosine distance} = 1-Cos(A,B)
\]

\noindent (Informazioni ricavate da \cite{site:weaviate-distance-metrics}).

\paragraph{Ricerca ibrida}
Il tipo di ricerca applicata in Weaviate per questo progetto è stata la ricerca ibridia che sfrutta sia BM25 che la \emph{Vector search} per poter stabilire uno score per i chunk.

\subparagraph{\gls{RRF}}
L'RRF score è il calcolo attreverso il quale riusciamo ad avere uno score unico per la ricerca ibrida.
Ad ogni documento viene assegnato un punteggio che equivale alla somma dei reciproci dei suoi piazzamenti nelle varie ranked list ottenute tramite gli altri algoritmi utilizzati nella ricerca.

\[
\text{RFF} = \sum_{d \in D} (\frac{1}{k+r(d)})    
\]

\noindent Per esempio, nella tabella \ref{tab:ranking}, vengono dati tre chunk A, B, C e vengono classificati nella seguente maniera tramite i due ranking algorithm:

\begin{table}[H]
    \centering
    \begin{tabular}{|p{2cm} |p{2cm} |p{2cm}|}
        \hline
        Posizione & BM25 & Vector Search \\
        \hline
        1 & A & B \\
        \hline
        2 & B & C \\
        \hline
        3 & C & A \\
        \hline
    \end{tabular}
    \caption{Esempio di ranking per i documenti A, B, C tramite BM25 e Vector Search.}
    \label{tab:ranking}
\end{table}

\noindent Gli RRF score dei documenti A, B, C sono i seguenti:
\begin{table}[H]
    \centering
    \begin{tabular}{|p{3cm} | p{3cm} |}
        \hline
        Chunk & RRF score \\
        \hline
        A & 1/1 + 1/3 = 1.3\\
        \hline
        B & 1/2 + 1/1 = 1.5\\
        \hline
        C & 1/3 + 1/2 = 0.83\\
        \hline
    \end{tabular}
    \caption{Esempio di calcolo del RRF score per i documenti A, B, C.}
    \label{tab:hybridrank}
\end{table}

\noindent Nella tabella \ref{tab:hybridrank} abbiamo quindi che il miglior chunk da considerare è il chunk B seguito poi dal chunk A e dal C.\\
\\
\noindent (Informazioni ricavate da \cite{site:weaviate-hybrid-search}).

\subsubsection{L'idea}
\label{subsubsec:ideachunking}
Per migliorare la qualità del chunking sono state attuate due strategie:
\begin{itemize}
    \item Il chunk viene strutturato come segue: all'inizio sarà presente una lista di titoli consevutivi in ordine gerarchico per individuare il contesto del chunk. In base alla grandezza del chunk viene definita una quantità di token che definisce la lunghezza della lista dei titoli. Se questa grandezza viene superata si scarta il titolo più alto in ordine gerarchico fino a quando i token effettivi saranno minori rispetto alla quantità prestabilita.
    La grandezza scelta per la lista dei titoli equivale ai due ottavi della grandezza del chunk mentre il resto viene lasciato per il contenuto.
    \noindent Il contenuto del paragrafo viene concatenato separando le tabelle dal testo:
    \begin{itemize}
        \item Se viene trovata una tabella si cerca di inserire le intere righe all'interno del chunk in modo tale da non perdere informazioni sui dati;
        \item Se viene trovato del testo normale viene utilizzata la sliding window per inserire parte del contenuto del chunk precedente all'inzio del nuovo chunk.
    \end{itemize}

    Quando viene utilizzata la sliding window quindi si creerà l'\emph{\gls{overlap}}\glsfirstoccur del contenuto.
    L'overlap è utile per due motivi:
    \begin{itemize}
        \item Se ci sono n chunk consecutivi nella lista dei chunk migliori è possibile unirli in modo deterministico, inoltre anche il modello è in grando di riconoscere questa continuità;
        \item Senza di esso ci sarebbero delle frasi spezzate prive di significato all'interno dei chunk.
    \end{itemize}

    Come esempio un documento potrebbe avere la seguente struttura:
    \begin{tcolorbox}[colback=white, colframe=black]
        1 Titolo\\
        testo\\
        tabella\\
        1.1 Sottotitolo\\
        testo\\
        1.1.1 Sottotitolo\\
        testo\\
        1.1.2 Sottotitolo\\
        testo\\
    \end{tcolorbox}

    Assumiamo che ogni titolo è composto da 1 token, ogni componente testuale è composta da 6 token e ogni riga della tabella da 5 token. Il chunk può essere composto al massimo da 8 token.
    \begin{tcolorbox}[colback=white, colframe=black]
        \begin{itemize}
            \item Chunk1: 1 Titolo:testo (7 token)
            \item Chunk2: 1 Titolo: prima riga della tabella (6 token)
            \item Chunk3: 1 Titolo: seconda riga della tabella (6 token)
            \item Chunk4: 1 Titolo| 1.1 Sottotitolo: testo (8 token)
            \item Chunk5: 1.1 Sottotitolo | 1.1.1 Sottotitolo: testo (8 token -> Qui viene eliminato "1 Titolo" perchè sennò si sforerebbe la grandezza prestabilita)
            \item Chunk6: 1.1 Sottotitolo | 1.1.2 Sottotitolo: testo (8 token -> Come nel chunk precedente viene eliminato "1 Titolo")
        \end{itemize}
    \end{tcolorbox}
    
    \item Pulizia del testo: le serie di caratteri  (come spazi, newline, '-', '*', altro), scelti prima di effettuare la pulizia, vengono sostituiti con un unico carattere dello stesso tipo.
    \noindent Ogni carattere è composto da un singolo token e quindi i chunk nel caso in cui non si eliminassero queste ripetizioni avrebbero dei caratteri superflui che occuperebbero spazio inutilmente, ci sarebbe il rischio di creare più chunk del dovuto.  
\end{itemize}

\section{Pianificazione del lavoro}
Le attività per sviluppare il lavoro e le ore previste per ognunga di esse sono riportate nella tabella successiva.
Come si può notare dal diagramma di Gantt diverse attività si sovrappongono e questo accade perchè diverse di queste ultime hanno dei punti in comune. 

\subsection{Pianificazione delle attività}
\begin{table}[H]
    \centering
    \begin{tabular}{p{2cm} p{8cm} p{2cm}}
        \hline
        Numero attività & Attività & Ore previste \\
        \hline
        1 & Studio introduttivo su Natural Language Processing e Large Language Model & 16 \\
        \hline
        2 & Studio delle tecniche di estrazione di testo e dei principali tool nell'ambito dell'NLP & 16 \\
        \hline
        3 & Studio dell'attuale implementazione del chatbot basato su retrueval-augmented LLM & 16 \\
        \hline
        4 & Analisi dei requisiti con studio delle casistiche da gestire & 30 \\
        \hline
        5 & Progettazione delle varie componenti richieste nel paragrafo  & 70 \\
        \hline
        6 & Implementazione del software & 100 \\
        \hline
        7 & Test e sperimentazione del software & 24 \\
        \hline
        8 & Documentazione & 48 \\
        \hline
    \end{tabular}
    \caption{Tabella di pianificazione delle attività.}
    \label{tab:preventivo}
\end{table}

\subsection{Diagramma di Gantt delle attività}
Viene mostrato il diagramma di Gantt delle attività svolte durante le nove settimane dello stage.

\begin{figure}[H]
    \centering
    \begin{ganttchart}[
        expand chart=\textwidth,
        hgrid=true,
        vgrid=true
        ]{1}{9}
        \gantttitlelist{1,...,9}{1} \\
        \ganttbar{Studio NLP e LLM}{1}{1} \\
        \ganttbar{Studio tecniche e tool esistenti}{1}{2} \\
        \ganttbar{Studio attuale implementazione chatbot}{2}{2} \\
        \ganttbar{Analisi dei requisiti}{2}{3} \\
        \ganttbar{Progettazione}{3}{5} \\
        \ganttbar{Implementazione del software}{5}{8} \\
        \ganttbar{Test e sperimentazione del software}{8}{9} \\
        \ganttbar{Documentazione}{1}{9} 
    \end{ganttchart}
    \caption{Diagramma di Gantt delle attività.}
\end{figure}



